// & (AND 논리 연산자)
// 비교하는 비트가 모두 1이면 1을 반환한다.
const b1 = 2 & 3;
console.log(b1); //2
//2 0010
//3 0011
//  0010 = 2

// | (OR 논리 연산자)
// 비교하는 비트 중에서 하나라도 1이면 1을 반환한다.
const b2 = 2 | 3;
console.log(b2); //3
//2 0010
//3 0011
//  0011 = 3

// ^ (배타 논리 연산자)
// 비교하는 두 개의 비트가 같으면 0을, 다르면 1을 반환한다.
const b3 = 5 ^ 3;
console.log(b3); //6
//5 0101
//3 0011
//  0110 = 6

// ~ (부정 논리 연산자)
// 피연산자가 하나뿐이며 비트의 값들을 반전시킨다.
// 1의 보수(One's Complement)방식으로서 비트를 반전시켜 음수를 표현한다.
const b4 = ~ 4;
console.log(b4); //-4
//0000 0100 4
//1111 1011 -4

// << (왼쪽 시프트 연산자)
// 지정한 수만큼 비트 전체를 왼쪽으로 이동한다.
// 몇 칸 이동했는지에 따라 2의 제곱만큼 수가 곱해진다.
const b5 = 4 << 2;
console.log(b5); //16
//4를 2비트 왼쪽으로 이동한다.
//0000 0100 4
//0000 1000 8(1비트 이동)
//0001 0000 16(2비트 이동)
//4 * 2 * 2

// >> (오른쪽 시프트 연산자)
// 지정한 수만큼 비트 전체를 오른쪽으로 이동한다.
// 오른쪽에 있는 비트가 소멸되기 때문에 규칙성이 없다.
const b6 = 4 >> 2;
console.log(b6); //1
//4를 2비트 오른쪽으로 이동한다.
//0000 0100 4
// 000 0010 2(1비트 이동)
//  00 0001 1(2비트 이동)

// >>> (부호 없는 오른쪽 시프트 연산자)
// 지정한 수만큼 32비트 숫자의 모든 비트를 오른쪽으로 이동하며 빈 비트는 전부 0으로 채운다.
// 양수에서는 부호 있는 오른쪽 시프트와 동일하게 동작하지만 음수일 경우 다르다. → 빈 비트를 0으로 채우며 음수의 2진 표현을 양수로 간주하기 때문이다.
const b7 = 5 >>> 2;          
const b8 = -5 >>> 2;                    

console.log(b7); //1
//  00000000000000000000000000000101 5
//  00000000000000000000000000000001 1(2비트 이동)

console.log(b8); //1073741822
// -00000000000000000000000000000101(=11111111111111111111111111111010) -5
//  00111111111111111111111111111110 1073741822(2비트 이동)

